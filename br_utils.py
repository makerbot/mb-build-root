# Common code for configuring and building build-root

import os
import shutil
import subprocess


this_dir = os.path.realpath(os.path.dirname(__file__))

def run_cmd(cmd):
    print(' '.join(cmd))
    subprocess.check_call(cmd, cwd=this_dir)

def set_install_dir(install_dir):
    global config_override
    config_override = {
        'BR2_TOOLCHAIN_EXTERNAL_PATH':
            os.path.join(install_dir, 'linaro-linux-gnu'),
        'BR2_PACKAGE_BUSYBOX_CONFIG':
            os.path.join(this_dir, 'busybox.mbconfig'),
    }

# Set a sane default here so that we shouldn't have to worry about this
set_install_dir(os.path.realpath(os.path.join(this_dir, '../../Install')))

config_src = os.path.join(this_dir, 'mbdefconfig')
debug_src = os.path.join(this_dir, 'mbdefconfig.debug')
config_gen = os.path.join(this_dir, 'configs/mb_defconfig')

def read_lines(files):
    """ Read in and yield lines from the given files. """
    for file in files:
        with open(file) as src:
            for line in src:
                yield line.rstrip()

def read_and_filter_lines(files, clean=False):
    """
    Read in, filter and yield lines from the given files.

    Each line read in is filtered according to whether it is
    an assignment to a config key that is a key in the
    config_override dict.  If it is, the value assigned is
    overriden to the value from the dict, or an empty string
    if clean is True.
    """
    for line in read_lines(files):
        var = line.split('=')[0]
        if var not in config_override:
            yield line.rstrip()
        elif clean:
            yield var + '=""'
        else:
            yield '%s="%s"' % (var, config_override[var])

def make_defconfig(debug=False):
    """
    Generate the contents of our defconfig file

    This file is generated from the checked in mbdefconfig, and
    when debugging is selected, additional defconfig entries are
    added from mbdefconfig.debug.  We override mbdefconfig lines
    which specify absolute filepaths so that the absolute
    filepaths are correct for the current machine.
    """
    files = [config_src]
    if debug:
        files.append(debug_src)

    for line in read_and_filter_lines(files):
        yield line

def write_lines(output_path, lines):
    """ Write lines out to output_path """
    with open(output_path, 'w') as f:
        for line in lines:
            f.write(line)
            f.write('\n')

def make_config(debug=False):
    """
    Ensure that the full configuration has been created

    Creates the defconfig using make_defconfig() and then invokes
    make in order to create the full configuration.
    """
    # Just always write the defconfig
    write_lines(config_gen, make_defconfig(debug))

    # Create the full configuration file
    run_cmd(['make', 'mb_defconfig'])

def write_mbdefconfig(debug=False):
    """
    Write the generated defconfig back to mbdefconfig

    This clears out any autogenerated fields to keep things clean.  When
    debug is true, it will write any generated defconfig lines not in
    mbdefconfig into mbdefconfig.debug.
    """
    src_lines = read_and_filter_lines([config_gen], clean=True)
    if debug:
        # Sure do wish we just had an ordered set
        from collections import OrderedDict
        lines = OrderedDict((l,0) for l in src_lines)
        dropped_lines = []
        for line in read_and_filter_lines([config_src], clean=True):
            if line not in lines:
                dropped_lines.append(line)
            else:
                del lines[line]
        if dropped_lines:
            print('WARNING: Missing lines from the new debug config:\n')
            print('\n'.join(dropped_lines))
            print('\nThe build system does not support removing packages '
                  'from only the debug config, these lines will be added back.')
        write_lines(debug_src, lines)
    else:
        write_lines(config_src, src_lines)
